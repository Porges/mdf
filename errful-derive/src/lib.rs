use darling::{ast, FromDeriveInput, FromField, FromMeta, FromVariant};
use proc_macro2::{Ident, Span, TokenStream};
use quote::{format_ident, quote};
use syn::{parse_macro_input, DeriveInput, Type};

#[derive(FromDeriveInput, Debug)]
#[darling(attributes(error), supports(struct_any, enum_any))]
struct Opts {
    // actual options
    display: Option<String>,

    #[darling(flatten)]
    basic: BasicOptions,

    // magically generated by darling
    data: Data,
}

#[derive(FromMeta, Debug)]
struct BasicOptions {
    /// Exit code to use if this is returned from `main`
    exit_code: Option<u8>,

    /// URL to show for this error
    url: Option<String>,

    /// The error code
    code: Option<String>,

    /// The severity of the error
    severity: Option<syn::Path>,

    /// Donâ€™t show the error message for this error when printing a chain
    #[darling(default)]
    transparent: bool,
}

type Data = ast::Data<EnumVariant, StructField>;

#[proc_macro_derive(Error, attributes(error, label))]
pub fn derive_errful(input: proc_macro::TokenStream) -> proc_macro::TokenStream {
    let input = input;
    let input = parse_macro_input!(input);

    let res = move || -> Result<proc_macro::TokenStream, darling::Error> {
        let opts = Opts::from_derive_input(&input)?;
        let source_method = generate_source_function(&opts.data)?;
        let labels_fn = generate_labels_function(&opts.data)?;

        let DeriveInput { ident, .. } = input;
        let display_impl = opts.display.as_deref().map(|display| {
            quote! {
                #[automatically_derived]
                impl ::core::fmt::Display for #ident {
                    fn fmt(&self, __formatter: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        write!(__formatter, #display)
                    }
                }
            }
        });

        let request_ident = format_ident!("__request");

        // exit code is provided
        let provide_exit_code = provide_value(
            &opts,
            &request_ident,
            |o| o.exit_code.as_ref(),
            |exit_code| quote! { ::std::process::ExitCode::from(#exit_code) },
        );

        // TODO: backtrace is provided

        let url_fn = generate_value_function(
            &opts,
            Ident::new("url", Span::call_site()),
            quote! { ::url::Url },
            |o| o.url.as_deref(),
            |url: &str| quote! { ::errful::protocol::url!(#url) },
        );

        let code_fn = generate_value_function(
            &opts,
            Ident::new("code", Span::call_site()),
            quote! { &'static str },
            |o| o.code.as_deref(),
            |code: &str| quote! { #code },
        );

        let severity_fn = generate_value_function(
            &opts,
            Ident::new("severity", Span::call_site()),
            quote! { &dyn ::errful::protocol::PrintableSeverity },
            |o| o.severity.as_ref(),
            |severity| quote! { &#severity },
        );

        let transparent_fn = generate_required_value_function(
            &opts,
            Ident::new("transparent", Span::call_site()),
            quote! { bool },
            |o| o.transparent,
            |transparent| quote! { #transparent },
        );

        let source_code = find_source_code(&opts.data)?;
        let source_code = source_code.map(|source_code| {
            quote! {
                fn source_code(&self) -> Option<&str> {
                    Some(#source_code)
                }
            }
        });

        let output = quote! {
            #[automatically_derived]
            impl ::core::error::Error for #ident {
                #source_method

                fn provide<'a>(&'a self, #request_ident: &mut ::core::error::Request<'a>) {
                    use ::std::borrow::Borrow;
                    #request_ident.provide_ref::<dyn ::errful::Errful>(self);
                    #provide_exit_code
                }
            }

            #[automatically_derived]
            impl ::errful::Errful for #ident {
                #url_fn
                #code_fn
                #severity_fn
                #transparent_fn
                #labels_fn
                #source_code
            }

            #display_impl
        };

        Ok(output.into())
    };

    match res() {
        Ok(res) => res,
        Err(err) => err.write_errors().into(),
    }
}

#[derive(Debug, FromVariant)]
#[darling(attributes(error))]
struct EnumVariant {
    /// The name of the variant:
    ident: syn::Ident,

    /// The variant's fields:
    fields: ast::Fields<StructField>,

    #[darling(flatten)]
    basic: BasicOptions,
}

#[derive(Debug, FromField)]
#[darling(attributes(error))]
struct StructField {
    /* Fields provided by darling: */
    /// The name of the field:
    ident: Option<syn::Ident>,

    /// The type of the field:
    ty: syn::Type,

    /* Actual options: */
    // is this the source of the error?
    #[darling(default)]
    source: bool,

    // labels
    label: Option<LabelTarget>,
    source_id: Option<String>,

    // source code
    #[darling(default)]
    source_code: bool,
}

/// The source of an errful label can either be
/// a field on the struct or a literal string.
#[derive(Debug)]
enum LabelTarget {
    Field(syn::Ident),
    Literal(String),
}

impl FromMeta for LabelTarget {
    fn from_meta(item: &syn::Meta) -> darling::Result<Self> {
        String::from_meta(item)
            .map(LabelTarget::Literal)
            .or_else(|_| syn::Ident::from_meta(item).map(LabelTarget::Field))
    }
}

fn generate_source_function(data: &Data) -> darling::Result<TokenStream> {
    let read_source_field = |target: &mut dyn FnMut(TokenStream) -> TokenStream,
                             fields: &[StructField]| {
        if fields.len() == 1 {
            // TODO, newtype
        }

        // TODO: need to check for more than one source field
        // and produce an error
        for (ix, field) in fields.iter().enumerate() {
            let field_name = name_for_field((ix, field));
            if field.source
                || field
                    .ident
                    .as_ref()
                    .map(|i| i == "source")
                    .unwrap_or_default()
            {
                let target = target(field_name);
                if is_optional(&field.ty) {
                    return quote! { #target.map(|s| s.borrow()) };
                } else {
                    return quote! { Some(#target.borrow()) };
                }
            }
        }

        quote! { None }
    };

    let contents = match data {
        ast::Data::Enum(variants) => {
            let cases = variants.iter().map(|v| {
                let name = &v.ident;
                let mut field = None;
                let source = read_source_field(
                    &mut |name| {
                        field = Some(name.clone());
                        quote! { #name }
                    },
                    &v.fields.fields,
                );
                if let Some(field) = field {
                    quote! {
                        Self::#name {#field, ..} => #source,
                    }
                } else {
                    quote! {
                        Self::#name {..} => #source,
                    }
                }
            });
            quote! {
                match self {
                    #(#cases)*
                    _ => None,
                }
            }
        }
        ast::Data::Struct(fields) => {
            let result = read_source_field(&mut |name| quote! { self.#name }, &fields.fields);
            quote! {
                #result
            }
        }
    };

    let result = quote! {
        fn source(&self) -> Option<&(dyn ::core::error::Error + 'static)> {
            use std::borrow::Borrow;
            #contents
        }
    };

    Ok(result)
}

fn generate_labels_function(data: &Data) -> darling::Result<Option<TokenStream>> {
    let ast::Data::Struct(struct_data) = data else {
        return Ok(None);
    };

    let mut labels = Vec::new();

    for (ix, field) in struct_data.fields.iter().enumerate() {
        let Some(label) = &field.label else { continue };

        let field_name = name_for_field((ix, field));

        let source_id = match &field.source_id {
            Some(id) => quote! { Some(#id) },
            None => quote! { None },
        };

        let value = match label {
            LabelTarget::Field(ident) => {
                quote! {
                   ::errful::protocol::Label::new_error(
                       #source_id,
                       self.#ident.borrow(),
                       self.#field_name)
                }
            }
            LabelTarget::Literal(label) => {
                quote! {
                    ::errful::protocol::Label::new_literal(#source_id, #label, self.#field_name)
                }
            }
        };

        labels.push(value);
    }

    if labels.is_empty() {
        return Ok(None);
    }

    let result = Some(quote! {
        fn labels(&self) -> Option<::std::vec::Vec<::errful::protocol::Label>> {
            use ::std::borrow::Borrow;
            Some(vec![
                #(#labels),*
            ])
        }
    });

    Ok(result)
}

fn find_source_code(data: &Data) -> darling::Result<Option<TokenStream>> {
    if let ast::Data::Struct(struct_data) = data {
        // TODO error if specified more than once
        Ok(field_ref(&struct_data.fields, |f| f.source_code))
    } else {
        Ok(None)
    }
}

fn field_ref<'a>(
    fields: impl IntoIterator<Item = &'a StructField>,
    predicate: impl Fn(&StructField) -> bool,
) -> Option<TokenStream> {
    for (field_index, field) in fields.into_iter().enumerate() {
        if predicate(field) {
            let field_name = name_for_field((field_index, field));
            return Some(quote! { &self.#field_name });
        }
    }

    None
}

fn name_for_field(field: (usize, &StructField)) -> TokenStream {
    if let Some(ident) = &field.1.ident {
        quote! { #ident }
    } else {
        let ix = proc_macro2::Literal::usize_unsuffixed(field.0);
        quote! { #ix }
    }
}

fn is_optional(ty: &Type) -> bool {
    // TODO: bad
    // instead use a trait for source_code
    // maybe also castaway
    let Type::Path(p) = ty else { return false };
    let Some(last) = p.path.segments.last() else {
        return false;
    };

    last.ident == "Option"
}

fn generate_value_function<'a, T: ?Sized + 'a>(
    opts: &'a Opts,
    name: proc_macro2::Ident,
    result_t: TokenStream,
    proj: impl Fn(&'a BasicOptions) -> Option<&'a T>,
    quote_t: impl Fn(&'a T) -> TokenStream,
) -> Option<TokenStream> {
    if let ast::Data::Enum(variants) = &opts.data {
        let cases = Vec::from_iter(variants.iter().filter_map(|v| {
            let ident = &v.ident;
            let quoted = quote_t(proj(&v.basic)?);
            Some(quote! { Self::#ident{..} => Some(#quoted), })
        }));

        if !cases.is_empty() {
            let base_case = match proj(&opts.basic) {
                Some(base_value) => {
                    let quoted = quote_t(base_value);
                    quote! { _ => Some(#quoted), }
                }
                _ => quote! { _ => None, },
            };

            return Some(quote! {
                fn #name(&self) -> Option<#result_t> {
                    match self {
                        #(#cases)*
                        #base_case
                    }
                }
            });
        }
    }

    proj(&opts.basic).map(|base_value| {
        let quoted = quote_t(base_value);
        quote! {
            fn #name(&self) -> Option<#result_t> {
                Some(#quoted)
            }
        }
    })
}

fn generate_required_value_function<'a, T: 'a>(
    opts: &'a Opts,
    name: proc_macro2::Ident,
    result_t: TokenStream,
    proj: impl Fn(&'a BasicOptions) -> T,
    quote_t: impl Fn(T) -> TokenStream,
) -> TokenStream {
    if let ast::Data::Enum(variants) = &opts.data {
        let cases = Vec::from_iter(variants.iter().map(|v| {
            let ident = &v.ident;
            let quoted = quote_t(proj(&v.basic));
            quote! { Self::#ident{..} => #quoted, }
        }));

        if !cases.is_empty() {
            let base_case = {
                let quoted = quote_t(proj(&opts.basic));
                quote! { _ => #quoted, }
            };

            return quote! {
                fn #name(&self) -> #result_t {
                    match self {
                        #(#cases)*
                        #base_case
                    }
                }
            };
        }
    }

    let quoted = quote_t(proj(&opts.basic));
    quote! {
        fn #name(&self) -> #result_t {
            #quoted
        }
    }
}

fn provide_value<'a, T: ?Sized + 'a>(
    opts: &'a Opts,
    request: &Ident,
    proj: impl Fn(&'a BasicOptions) -> Option<&'a T>,
    quote_t: impl Fn(&'a T) -> TokenStream,
) -> Option<TokenStream> {
    if let ast::Data::Enum(variants) = &opts.data {
        let cases = Vec::from_iter(variants.iter().filter_map(|v| {
            let ident = &v.ident;
            let quoted = quote_t(proj(&v.basic)?);
            Some(quote! { Self::#ident{..} => #request.provide_value(#quoted), })
        }));

        if !cases.is_empty() {
            let base_case = match proj(&opts.basic) {
                Some(base_value) => {
                    let quoted = quote_t(base_value);
                    quote! { _ => #request.provide_value(#quoted), }
                }
                _ => quote! { _ => {}, },
            };

            return Some(quote! {
                match self {
                    #(#cases)*
                    #base_case
                };
            });
        }
    }

    proj(&opts.basic).map(|base_value| {
        let quoted = quote_t(base_value);
        quote! { #request.provide_value(#quoted); }
    })
}
